<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="方案1、   如何有效地监控到App发生卡顿，同时在发生卡顿时正确记录app的状态，如堆栈信息，CPU占用，内存占用，IO使用情况等等； 2、   统计到的卡顿信息上报到监控平台，需要处理分析分类上报内容，并通过平台Web直观简便地展示，供开发跟进处理。 如何从App层面监控卡顿？我们的思路是，一般主线程过多的UI绘制、大量的IO操作或是大量的计算操作占用CPU，导致App界面卡顿。只要我们能在发">
<meta name="keywords" content="code article social">
<meta property="og:type" content="article">
<meta property="og:title" content="Android卡顿监控方案">
<meta property="og:url" content="http://yoursite.com/2018/06/20/Android卡顿监控方案/index.html">
<meta property="og:site_name" content="Hello World">
<meta property="og:description" content="方案1、   如何有效地监控到App发生卡顿，同时在发生卡顿时正确记录app的状态，如堆栈信息，CPU占用，内存占用，IO使用情况等等； 2、   统计到的卡顿信息上报到监控平台，需要处理分析分类上报内容，并通过平台Web直观简便地展示，供开发跟进处理。 如何从App层面监控卡顿？我们的思路是，一般主线程过多的UI绘制、大量的IO操作或是大量的计算操作占用CPU，导致App界面卡顿。只要我们能在发">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://ask.qcloudimg.com/http-save/yehe-1069749/uvhkbz56gj.jpeg?imageView2/2/w/1620">
<meta property="og:image" content="https://ask.qcloudimg.com/http-save/yehe-1069749/0sdlj2iy3v.jpeg?imageView2/2/w/1620">
<meta property="og:image" content="https://ask.qcloudimg.com/http-save/yehe-1069749/gnb462r3jo.png?imageView2/2/w/1620">
<meta property="og:image" content="https://ask.qcloudimg.com/http-save/yehe-1069749/fvhqoqjmzv.png?imageView2/2/w/1620">
<meta property="og:image" content="https://ask.qcloudimg.com/http-save/yehe-1069749/gjls4pretw.jpeg?imageView2/2/w/1620">
<meta property="og:image" content="https://ask.qcloudimg.com/http-save/yehe-1069749/7wjcbclqwr.jpeg?imageView2/2/w/1620">
<meta property="og:updated_time" content="2018-06-20T10:59:15.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android卡顿监控方案">
<meta name="twitter:description" content="方案1、   如何有效地监控到App发生卡顿，同时在发生卡顿时正确记录app的状态，如堆栈信息，CPU占用，内存占用，IO使用情况等等； 2、   统计到的卡顿信息上报到监控平台，需要处理分析分类上报内容，并通过平台Web直观简便地展示，供开发跟进处理。 如何从App层面监控卡顿？我们的思路是，一般主线程过多的UI绘制、大量的IO操作或是大量的计算操作占用CPU，导致App界面卡顿。只要我们能在发">
<meta name="twitter:image" content="https://ask.qcloudimg.com/http-save/yehe-1069749/uvhkbz56gj.jpeg?imageView2/2/w/1620">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"hide","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/06/20/Android卡顿监控方案/"/>





  <title>Android卡顿监控方案 | Hello World</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hello World</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/20/Android卡顿监控方案/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason chong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://www.saifurrahman.com/wp-content/uploads/2016/04/HelloWorld.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hello World">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Android卡顿监控方案</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-06-20T18:59:15+08:00">
                2018-06-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">-Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h3><p>1、   如何有效地监控到App发生卡顿，同时在发生卡顿时正确记录app的状态，如堆栈信息，CPU占用，内存占用，IO使用情况等等；</p>
<p>2、   统计到的卡顿信息上报到监控平台，需要处理分析分类上报内容，并通过平台Web直观简便地展示，供开发跟进处理。</p>
<h3 id="如何从App层面监控卡顿？"><a href="#如何从App层面监控卡顿？" class="headerlink" title="如何从App层面监控卡顿？"></a>如何从App层面监控卡顿？</h3><p>我们的思路是，一般主线程过多的UI绘制、大量的IO操作或是大量的计算操作占用CPU，导致App界面卡顿。只要我们能在发生卡顿的时候，捕捉到主线程的堆栈信息和系统的资源使用信息，即可准确分析卡顿发生在什么函数，资源占用情况如何。那么问题就是如何有效检测Android主线程的卡顿发生，目前业界两种主流有效的app监控方式如下：</p>
<p>1、   利用UI线程的Looper打印的日志匹配；</p>
<p>2、   使用Choreographer.FrameCallback</p>
<h3 id="方式1：-利用UI线程的Looper打印的日志匹配判断是否卡顿"><a href="#方式1：-利用UI线程的Looper打印的日志匹配判断是否卡顿" class="headerlink" title="方式1： 利用UI线程的Looper打印的日志匹配判断是否卡顿"></a>方式1： 利用UI线程的Looper打印的日志匹配判断是否卡顿</h3><p>Android主线程更新UI。如果界面1秒钟刷新少于60次，即FPS小于60，用户就会产生卡顿感觉。简单来说，Android使用消息机制进行UI更新，UI线程有个Looper，在其loop方法中会不断取出message，调用其绑定的Handler在UI线程执行。如果在handler的dispatchMesaage方法里有耗时操作，就会发生卡顿。</p>
<h4 id="Looper-loop-的源码"><a href="#Looper-loop-的源码" class="headerlink" title="Looper.loop( )的源码"></a>Looper.loop( )的源码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Looper me = myLooper();</span><br><span class="line">    <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123; </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> MessageQueue queue = me.mQueue;</span><br><span class="line">    <span class="comment">// Make sure the identity of this thread is that of the local process,</span></span><br><span class="line">    <span class="comment">// and keep track of what that identity token actually is.</span></span><br><span class="line">    Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();    </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Message msg = queue.next(); </span><br><span class="line">            <span class="comment">// might block</span></span><br><span class="line">            <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// This must be in a local variable, in case a UI event sets the logger</span></span><br><span class="line">            Printer logging = me.mLogging;        </span><br><span class="line">            <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">                logging.println(<span class="string">"&gt;&gt;&gt;&gt;&gt; Dispatching to "</span> + msg.target + <span class="string">" "</span> +</span><br><span class="line">                msg.callback + <span class="string">": "</span> + msg.what);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            msg.target.dispatchMessage(msg);        </span><br><span class="line">            <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">                logging.println(<span class="string">"&lt;&lt;&lt;&lt;&lt; Finished to "</span> + msg.target + <span class="string">" "</span> + msg.callback);</span><br><span class="line">            &#125;        </span><br><span class="line">            <span class="comment">// Make sure that during the course of dispatching the</span></span><br><span class="line">            <span class="comment">// identity of the thread wasn't corrupted.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> newIdent = Binder.clearCallingIdentity();        </span><br><span class="line">            <span class="keyword">if</span> (ident != newIdent) &#123;</span><br><span class="line">                Log.wtf(TAG, <span class="string">"Thread identity changed from 0x"</span></span><br><span class="line">                    + Long.toHexString(ident) + <span class="string">" to 0x"</span></span><br><span class="line">                    + Long.toHexString(newIdent) + <span class="string">" while dispatching to "</span></span><br><span class="line">                    + msg.target.getClass().getName() + <span class="string">" "</span></span><br><span class="line">                    + msg.callback + <span class="string">" what="</span> + msg.what);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            msg.recycleUnchecked();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只要检测第25行代码msg.target.dispatchMessage(msg) 的执行时间，就能检测到部分UI线程是否有耗时的操作。注意到这行执行代码的前后，有两个logging.println函数，如果设置了logging，会分别打印出”&gt;&gt;&gt;&gt;&gt; Dispatching to “和”&lt;&lt;&lt;&lt;&lt; Finished to “这样的日志，这样我们就可以通过两次log的时间差值，来计算dispatchMessage的执行时间，从而设置阈值判断是否发生了卡顿</p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-1069749/uvhkbz56gj.jpeg?imageView2/2/w/1620" alt=""></p>
<h4 id="如何设置logging呢？"><a href="#如何设置logging呢？" class="headerlink" title="如何设置logging呢？"></a>如何设置logging呢？</h4><p>我们看第19行代码me.mLogging源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Looper</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> Printer mLogging;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessageLogging</span><span class="params">(@Nullable Printer printer)</span> </span>&#123;  </span><br><span class="line">        mLogging = printer;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Printer</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">println</span><span class="params">(String x)</span></span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Looper的mLogging是私有的，并且提供了setMessageLogging(@Nullable Printer printer)方法，所以我们可以自己实现一个Printer，在通过setMessageLogging()方法传入即可，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockDetectByPrinter</span> </span>&#123;    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Looper.getMainLooper().setMessageLogging(<span class="keyword">new</span> Printer() &#123; </span><br><span class="line">           <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String START = <span class="string">"&gt;&gt;&gt;&gt;&gt; Dispatching"</span>; </span><br><span class="line">           <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String END = <span class="string">"&lt;&lt;&lt;&lt;&lt; Finished"</span>;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(String x)</span> </span>&#123;</span><br><span class="line">              <span class="keyword">if</span> (x.startsWith(START)) &#123;</span><br><span class="line">                    LogMonitor.getInstance().startMonitor();</span><br><span class="line">                &#125;  </span><br><span class="line">              <span class="keyword">if</span> (x.startsWith(END)) &#123;</span><br><span class="line">                    LogMonitor.getInstance().removeMonitor();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设置了logging后，loop方法会回调logging.println打印出每次消息执行的时间日志：”&gt;&gt;&gt;&gt;&gt; Dispatching to “和”&lt;&lt;&lt;&lt;&lt; Finished to “。BlockDetectByPrinter的使用则在Application的onCreate方法中调用 BlockDetectByPrinter.start() 即可。</p>
<p>我们可以简单实现一个LogMonitor来记录卡顿时候主线程的堆栈信息。当匹配到&gt;&gt;&gt;&gt;&gt; Dispatching时，执行startMonitor，会在1000ms（设定的卡顿阈值）后执行任务，这个任务负责在子线程（非UI线程）打印UI线程的堆栈信息。如果消息低于1000ms内执行完成，就可以匹配到&lt;&lt;&lt;&lt;&lt; Finished日志，那么在打印堆栈任务启动前执行removeMonitor取消了这个任务，则认为没有卡顿的发生；如果消息超过1000ms才执行完毕，此时认为发生了卡顿，并打印UI线程的堆栈信息。</p>
<h4 id="LogMonitor如何实现？"><a href="#LogMonitor如何实现？" class="headerlink" title="LogMonitor如何实现？"></a>LogMonitor如何实现？</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogMonitor</span> </span>&#123;    </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> LogMonitor sInstance = <span class="keyword">new</span> LogMonitor();    </span><br><span class="line"><span class="keyword">private</span> HandlerThread mLogThread = <span class="keyword">new</span> HandlerThread(<span class="string">"log"</span>);    </span><br><span class="line"><span class="keyword">private</span> Handler mIoHandler;    </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> TIME_BLOCK = <span class="number">1000L</span>;    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">LogMonitor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mLogThread.start();</span><br><span class="line">        mIoHandler = <span class="keyword">new</span> Handler(mLogThread.getLooper());</span><br><span class="line">    &#125; </span><br><span class="line">   </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Runnable mLogRunnable = <span class="keyword">new</span> Runnable() &#123;        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            StackTraceElement[] stackTrace = Looper.getMainLooper().getThread().getStackTrace();            </span><br><span class="line">            <span class="keyword">for</span> (StackTraceElement s : stackTrace) &#123;</span><br><span class="line">                sb.append(s.toString() + <span class="string">"\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            Log.e(<span class="string">"TAG"</span>, sb.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LogMonitor <span class="title">getInstance</span><span class="params">()</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">return</span> sInstance;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMonitor</span><span class="params">()</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">return</span> mIoHandler.hasCallbacks(mLogRunnable);</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startMonitor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mIoHandler.postDelayed(mLogRunnable, TIME_BLOCK);</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeMonitor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mIoHandler.removeCallbacks(mLogRunnable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们使用HandlerThread来构造一个Handler，HandlerThread继承自Thread，实际上就一个Thread，只不过比普通的Thread多了一个Looper，对外提供自己这个Looper对象的getLooper方法，然后创建Handler时将HandlerThread中的looper对象传入。这样我们的mIoHandler对象就是与HandlerThread这个非UI线程绑定的了，它处理耗时操作将不会阻塞UI。如果UI线程阻塞超过1000ms，就会在子线程中执行mLogRunnable，打印出UI线程当前的堆栈信息，如果处理消息没有超过1000ms，则会实时的remove掉这个mLogRunnable任务。</p>
<p>发生卡顿时打印出堆栈信息的大致内容如下，开发可以通过log定位耗时的地方。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">2017-10-14 23:56:41.031 </span><br><span class="line">android.renderscript.RenderScript.rsnContextCreate(Native Method) </span><br><span class="line">android.renderscript.RenderScript.create(RenderScript.java:1219) </span><br><span class="line">com.tencent.weread.util.UIUtil.&lt;clinit&gt;(SourceFile:580) </span><br><span class="line">com.tencent.weread.WeReadFragment.onViewCreated(SourceFile:179) </span><br><span class="line">moai.fragment.app.FragmentManagerImpl.moveToState(SourceFile:1023) </span><br><span class="line">moai.fragment.base.BaseFragmentActivity.onStart(SourceFile:82) </span><br><span class="line">android.app.Instrumentation.callActivityOnStart(Instrumentation.java:1171) </span><br><span class="line">android.app.Activity.performStart(Activity.java:5252) </span><br><span class="line">android.app.ActivityThread$H.handleMessage(ActivityThread.java:1212) </span><br><span class="line">android.os.Handler.dispatchMessage(Handler.java:102) </span><br><span class="line">android.app.ActivityThread.main(ActivityThread.java:5113) </span><br><span class="line">java.lang.reflect.Method.invokeNative(Native Method) </span><br><span class="line">com.android.internal.os.ZygoteInit.main(ZygoteInit.java:612) </span><br><span class="line">dalvik.system.NativeStart.main(Native Method)</span><br></pre></td></tr></table></figure>
<p>优点：用户使用app或者测试过程中都能从app层面来监控卡顿情况，一旦出现卡顿能记录app状态和信息， 只要dispatchMesaage执行耗时过大都会记录下来，不再有前面两种adb方式面临的问题与不足。</p>
<p>缺点：需另开子线程获取堆栈信息，会消耗少量系统资源。</p>
<p>在实际实现中，不同手机不同Android系统甚至是不同的ROM版本，Loop函数不一定都能打印出”&gt;&gt;&gt;&gt;&gt; Dispatching to “和”&lt;&lt;&lt;&lt;&lt; Finished to “这样的日志，导致该方式无法进行。</p>
<p>优化的策略：我们知道Loop函数开始和结束必会执行println打印日志，所以优化版本将卡顿的判断改为，Loop输出第一句log时当作startMonitor，输出下一句log时当作end时刻来解决这个问题。</p>
<h3 id="方式2：-利用Choreographer-FrameCallback监控卡顿"><a href="#方式2：-利用Choreographer-FrameCallback监控卡顿" class="headerlink" title="方式2： 利用Choreographer.FrameCallback监控卡顿"></a>方式2： 利用Choreographer.FrameCallback监控卡顿</h3><p>Choreographer.FrameCallback官方文档链接（<a href="https://developer.android.com/reference/android/view/Choreographer.FrameCallback.html）" target="_blank" rel="noopener">https://developer.android.com/reference/android/view/Choreographer.FrameCallback.html）</a></p>
<p>我们知道， Android系统每隔16ms发出VSYNC信号，来通知界面进行重绘、渲染，每一次同步的周期为16.6ms，代表一帧的刷新频率。SDK中包含了一个相关类，以及相关回调。理论上来说两次回调的时间周期应该在16ms，如果超过了16ms我们则认为发生了卡顿，利用两次回调间的时间周期来判断是否发生卡顿（这个方案是Android 4.1 API 16以上才支持）。</p>
<p>这个方案的原理主要是通过Choreographer类设置它的FrameCallback函数，当每一帧被渲染时会触发回调FrameCallback， FrameCallback回调void doFrame (long frameTimeNanos)函数。一次界面渲染会回调doFrame方法，如果两次doFrame之间的间隔大于16.6ms说明发生了卡顿。</p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-1069749/0sdlj2iy3v.jpeg?imageView2/2/w/1620" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockDetectByChoreographer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Choreographer.getInstance().postFrameCallback(<span class="keyword">new</span> Choreographer.FrameCallback() &#123; </span><br><span class="line">                   <span class="keyword">long</span> lastFrameTimeNanos = <span class="number">0</span>; </span><br><span class="line">                   <span class="keyword">long</span> currentFrameTimeNanos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFrame</span><span class="params">(<span class="keyword">long</span> frameTimeNanos)</span> </span>&#123; </span><br><span class="line">                    <span class="keyword">if</span>(lastFrameTimeNanos == <span class="number">0</span>)&#123;</span><br><span class="line">                        lastFrameTimeNanos == frameTimeNanos;</span><br><span class="line">                    &#125;</span><br><span class="line">                    currentFrameTimeNanos = frameTimeNanos;</span><br><span class="line">                    <span class="keyword">long</span> diffMs = TimeUnit.MILLISECONDS.convert(currentFrameTimeNanos-lastFrameTimeNanos, TimeUnit.NANOSECONDS);</span><br><span class="line">                    <span class="keyword">if</span> (diffMs &gt; <span class="number">16.6f</span>) &#123;            </span><br><span class="line">                       <span class="keyword">long</span> droppedCount = (<span class="keyword">int</span>)diffMs / <span class="number">16.6</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                        <span class="keyword">if</span> (LogMonitor.getInstance().isMonitor()) &#123;</span><br><span class="line">                        LogMonitor.getInstance().removeMonitor();                    </span><br><span class="line">                    &#125; </span><br><span class="line">                    LogMonitor.getInstance().startMonitor();</span><br><span class="line">                    Choreographer.getInstance().postFrameCallback(<span class="keyword">this</span>);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在每一帧被渲染时，记下了渲染的时间用来计算掉帧数，数据可以绘制出流畅度曲线；同时，获取isMonitor（）函数判断上一帧LogMonitor已经启动打印堆栈的任务，如果已启动，则移除LogMonitor，此时如果上一帧渲染的时间到现在已经超过了阈值，则已经执行了任务打印堆栈出来了；如果没有超过阈值则及时移除了任务。如果isMonitor返回false，没有LogMonitor回调任务，则开始新的一帧的监控任务。</p>
<p>优点：不仅可用来从app层面来监控卡顿，同时可以实时计算帧率和掉帧数，实时监测App页面的帧率数据，一旦发现帧率过低，可自动保存现场堆栈信息。</p>
<p>缺点：需另开子线程获取堆栈信息，会消耗少量系统资源。</p>
<h3 id="痛点1：如何保证捕获卡顿堆栈的准确性？"><a href="#痛点1：如何保证捕获卡顿堆栈的准确性？" class="headerlink" title="痛点1：如何保证捕获卡顿堆栈的准确性？"></a>痛点1：如何保证捕获卡顿堆栈的准确性？</h3><p>细心的同学可以发现，我们通过上述两种方案（Looper.loop和Choreographer.FrameCallback）可以判断是当前主线程是否发生了卡顿，进而在计算发现卡顿后的时刻dump下了主线程的堆栈信息。实际上，通过一个子线程，监控主线程的活动情况，计算发现超过阈值后dump下主线程的堆栈，那么生成的堆栈文件只是捕捉了一个时刻的现场快照。打个不太恰当的比方，相当于闭路电视监控只拍下了凶案发生后的惨状，而并没有录下这个案件发生的过程，那么作为警察的你只看到了结局，依然很难判断案情和凶手。在实际的运用中，我们也发现这种方式下获取到的堆栈情况，查看相关的代码和函数，经常已经不是发生卡顿的代码了。</p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-1069749/gnb462r3jo.png?imageView2/2/w/1620" alt=""></p>
<p>如图所示，主线程在T1~T2时间段内发生卡顿，上述方案中获取卡顿堆栈的时机已经是T2时刻。实际卡顿可能是这段时间内某个函数的耗时过大导致卡顿，而不一定是T2时刻的问题，如此捕获的卡顿信息就无法如实反应卡顿的现场。</p>
<p>我们看看在这之前微信iOS主线程卡顿监控系统是如何实现的捕获堆栈。微信iOS的方案是起检测线程每1秒检查一次，如果检测到主线程卡顿，就将所有线程的函数调用堆栈dump到内存中。本质上，微信iOS方案的计时起点是固定的，检查次数也是固定的。如果任务1执行花费了较长的时间导致卡顿，但由于监控线程是隔1秒扫一次的，可能到了任务N才发现并dump下来堆栈，并不能抓到关键任务1的堆栈。这样的情况的确是存在的，只不过现上监控量大走人海战术，通过概率分布抓到卡顿点，但依然不是最佳的捕获方案。</p>
<p>因此，摆在我们面前的是如何更加精准地获取卡顿堆栈。为了卡顿堆栈的准确度，我们想要能获取一段时间内的堆栈，而不是一个点的堆栈，如下图：</p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-1069749/fvhqoqjmzv.png?imageView2/2/w/1620" alt=""></p>
<p>我们采用高频采集的方案来获取一段卡顿时间内的多个堆栈，而不再是只有一个点的堆栈。这样的方案的优点是保证了监控的完备性，整个卡顿过程的堆栈都得以采样、收集和落地。</p>
<p>具体做法是在子线程监控的过程中，每一轮log输出或是每一帧开始启动monitor时，我们便已经开启了高频采样收集主线程堆栈的工作了。当下一轮log或者下一帧结束monitor时，我们判断是否发生卡顿（计算耗时是否超过阈值），来决定是否将内存中的这段堆栈集合落地到文件存储。也就是说，每一次卡顿的发生，我们记录了整个卡顿过程的多个高频采样堆栈。由此精确地记录下整个凶案发生的详细过程，供上报后分析处理（后文会阐述如何从一次卡顿中多个堆栈信息中提取出关键堆栈）。</p>
<h3 id="采样频率与性能消耗"><a href="#采样频率与性能消耗" class="headerlink" title="采样频率与性能消耗"></a>采样频率与性能消耗</h3><p>目前我们的策略是判断一个卡顿是否发生的耗时阈值是80ms（5*16.6ms），当一个卡顿达80ms的耗时，采集1~2个堆栈基本可以定位到耗时的堆栈。因此采样堆栈的频率我们设为52ms（经验值）。</p>
<p>当然，高频采集堆栈的方案，必然会导致app性能上带来的影响。为此，为了评估对App的性能影响，在上述默认设置的情况下，我们做一个简单的测试实验观察。</p>
<p>实验方法：ViVoX9 上运行微信读书App，使用卡顿监控与高频采样，和不使用卡顿监控的情况下，保持两次的操作动作相同，分析性能差异，数据如下：</p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-1069749/gjls4pretw.jpeg?imageView2/2/w/1620" alt=""></p>
<p>从实验结果可知，高频采样对性能消耗很小，可以不影响用户体验。</p>
<p>监控使用Choreographer.FrameCallback, 采样频率设52ms），最终结果是性能消耗带来的影响很小，可忽略：</p>
<p>1）     监控代码本身对主线程有一定的耗时，但影响很小，约0.1ms/S；</p>
<p>2）     卡顿监控开启后，增加0.1%的CPU使用；</p>
<p>3）     卡顿监控开启后，增加Davilk Heap内存约1MB；</p>
<p>4）     对于流量，文件可按天写入，压缩文件最大约100KB，一天上传一次</p>
<h3 id="痛点2：海量卡顿堆栈后该如何处理？"><a href="#痛点2：海量卡顿堆栈后该如何处理？" class="headerlink" title="痛点2：海量卡顿堆栈后该如何处理？"></a>痛点2：海量卡顿堆栈后该如何处理？</h3><p>卡顿堆栈上报到平台后，需要对上报的文件进行分析，提取和聚类过程，最终展示到卡顿平台。前面我们提到，每一次卡顿发生时，会高频采样到多个堆栈信息描述着这一个卡顿。做个最小的估算，每天上报收集2000个用户卡顿文件，每个卡顿文件dump下了用户遇到的10个卡顿，每个卡顿高频收集到30个堆栈，这就已经产生20001030=60W个堆栈。按照这个量级发展，一个月可产生上千万的堆栈信息，每个堆栈还是几十行的函数调用关系。这么大量的信息对存储，分析，页面展示等均带来相当大的压力。很快就能撑爆存储层，平台无法展示这么大量的数据，开发更是没办法处理这些多的堆栈问题。因而，海量卡顿堆栈成为我们另外一个面对的难题。</p>
<p>在一个卡顿过程中，一般卡顿发生在某个函数的调用上，在这多个堆栈列表中，我们把每个堆栈都做一次hash处理后进行排重分析，有很大的几率会是dump到同一个堆栈hash</p>
<h3 id="卡顿监控系统的处理流程"><a href="#卡顿监控系统的处理流程" class="headerlink" title="卡顿监控系统的处理流程"></a>卡顿监控系统的处理流程</h3><p><img src="https://ask.qcloudimg.com/http-save/yehe-1069749/7wjcbclqwr.jpeg?imageView2/2/w/1620" alt=""></p>
<h5 id="用户上报"><a href="#用户上报" class="headerlink" title="用户上报"></a>用户上报</h5><p>目前我们的策略是：</p>
<p>1、   通过后台配置下发，灰度0.2%的用户量进行卡顿监控和上报；</p>
<p>2、   如果用户反馈有卡顿问题，也可实时捞取卡顿日志来分析；</p>
<p>3、   每天灰度的用户一个机器上报一次，上报后删除文件不影响存储空间。</p>
<h5 id="后台解析"><a href="#后台解析" class="headerlink" title="后台解析"></a>后台解析</h5><p>1、主要负责处理上报的卡顿文件，过滤、去重、分类、反解堆栈、入库等流程；</p>
<p>2、自动回归修复好的卡顿问题，读取tapd 卡顿bug单的修复结果，更新平台展示，计算修复好的卡顿问题，后续版本是否重新出现（修复不彻底）</p>
<h5 id="平台展示"><a href="#平台展示" class="headerlink" title="平台展示"></a>平台展示</h5><p>上报处理后的卡顿展示平台 主要展示卡顿处理后的数据：</p>
<p>1、   以版本为维度展示卡顿问题列表，按照卡顿上报重复的次数降序列出；</p>
<p>2、   归类后展示每个卡顿的关键耗时代码，也可查看全部堆栈内容；</p>
<p>3、   支持操作卡顿记录，如搜索卡顿，提tapd单，标注已解决等；</p>
<p>4、   展示每个版本的卡顿问题修复数据情况，版本分布，监控修复后是否重现等。</p>
<h5 id="自动提单"><a href="#自动提单" class="headerlink" title="自动提单"></a>自动提单</h5><p>实际使用中，为了增强跟进效果，我们设立一些规则，比如卡顿重复上报超过100次，卡顿耗时达到1000ms等，自动提tapd bug单给开发处理，系统也会自动更新卡顿问题的修复情况和数据，开发只需定期review tapd bug单处理修复卡顿问题即可，整个卡顿系统从监控，上报，分析，聚类，展示，提单到回归，整个流程自动化实现，不再需要人工介入。</p>
<h5 id="实际应用效果"><a href="#实际应用效果" class="headerlink" title="实际应用效果"></a>实际应用效果</h5><p>1、接入产品：微信读书，企业微信，QQ邮箱</p>
<p>2、应用场景：现网用户的监控，发布前测试的监控，每天自动化运行的监控</p>
<p>3、发现问题：三个多月时间，归类后的卡顿过万，提bug单约500，开发已解决超过200个卡顿问题</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/06/20/web缓存策略/" rel="next" title="H5 缓存机制浅析">
                <i class="fa fa-chevron-left"></i> H5 缓存机制浅析
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/07/05/移动端h5首屏秒开方案/" rel="prev" title="移动端h5首屏秒开方案">
                移动端h5首屏秒开方案 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="http://www.saifurrahman.com/wp-content/uploads/2016/04/HelloWorld.jpg"
                alt="Jason chong" />
            
              <p class="site-author-name" itemprop="name">Jason chong</p>
              <p class="site-description motion-element" itemprop="description">一些平时记录收录的笔记或者原创</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">18</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#方案"><span class="nav-number">1.</span> <span class="nav-text">方案</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何从App层面监控卡顿？"><span class="nav-number">2.</span> <span class="nav-text">如何从App层面监控卡顿？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方式1：-利用UI线程的Looper打印的日志匹配判断是否卡顿"><span class="nav-number">3.</span> <span class="nav-text">方式1： 利用UI线程的Looper打印的日志匹配判断是否卡顿</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Looper-loop-的源码"><span class="nav-number">3.1.</span> <span class="nav-text">Looper.loop( )的源码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何设置logging呢？"><span class="nav-number">3.2.</span> <span class="nav-text">如何设置logging呢？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LogMonitor如何实现？"><span class="nav-number">3.3.</span> <span class="nav-text">LogMonitor如何实现？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方式2：-利用Choreographer-FrameCallback监控卡顿"><span class="nav-number">4.</span> <span class="nav-text">方式2： 利用Choreographer.FrameCallback监控卡顿</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#痛点1：如何保证捕获卡顿堆栈的准确性？"><span class="nav-number">5.</span> <span class="nav-text">痛点1：如何保证捕获卡顿堆栈的准确性？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#采样频率与性能消耗"><span class="nav-number">6.</span> <span class="nav-text">采样频率与性能消耗</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#痛点2：海量卡顿堆栈后该如何处理？"><span class="nav-number">7.</span> <span class="nav-text">痛点2：海量卡顿堆栈后该如何处理？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#卡顿监控系统的处理流程"><span class="nav-number">8.</span> <span class="nav-text">卡顿监控系统的处理流程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#用户上报"><span class="nav-number">8.0.1.</span> <span class="nav-text">用户上报</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#后台解析"><span class="nav-number">8.0.2.</span> <span class="nav-text">后台解析</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#平台展示"><span class="nav-number">8.0.3.</span> <span class="nav-text">平台展示</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#自动提单"><span class="nav-number">8.0.4.</span> <span class="nav-text">自动提单</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#实际应用效果"><span class="nav-number">8.0.5.</span> <span class="nav-text">实际应用效果</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jason chong</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
